#!/usr/bin/python3
#
# SPDX-License-Identifier: MIT

import argparse
import base64
import pathlib
import re
import sys

from cryptography.hazmat.primitives.asymmetric import ec, ed448, ed25519, rsa
from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat


def rec2key(rec):
    o = rec.split(maxsplit=3)
    keytype = int(o[2])
    key = base64.b64decode(o[3].replace(" ", ""))
    if keytype in {1, 5, 7, 8, 10}:
        if key[0] == 0:
            elen = int.from_bytes(key[1:3], byteorder="big")
        else:
            elen = key[0]

        if len(key) < elen + 1:
            sys.stderr.write("invalid RSA exponent length\n")
            return None

        e = int.from_bytes(key[1:1 + elen], byteorder="big")
        n = int.from_bytes(key[1 + elen:], byteorder="big")
        return rsa.RSAPublicNumbers(e, n).public_key()
    if keytype == 13:
        if len(key) != 64:
            sys.stderr.write(f"Wrong key size {len(key)} for ECDSA/P256, expected 64\n")
            return None
        x = int.from_bytes(key[0:32], byteorder="big")
        y = int.from_bytes(key[32:64], byteorder="big")
        try:
            return ec.EllipticCurvePublicNumbers(x, y, ec.SECP256R1()).public_key()
        except ValueError as e:
            sys.stderr.write("Invalid ECDSA/P256 key\n")
            sys.stderr.write(f"{e!s}\n")
            return None
    if keytype == 14:
        if len(key) != 96:
            sys.stderr.write(f"Wrong key size {len(key)} for ECDSA/P384, expected 96\n")
            return None
        x = int.from_bytes(key[0:48], byteorder="big")
        y = int.from_bytes(key[48:96], byteorder="big")
        try:
            return ec.EllipticCurvePublicNumbers(x, y, ec.SECP384R1()).public_key()
        except ValueError as e:
            sys.stderr.write("Invalid ECDSA/P384 key\n")
            sys.stderr.write(f"{e!s}\n")
            return None
    if keytype == 15:
        if len(key) != 32:
            sys.stderr.write(f"Wrong key size {len(key)} for Ed25519, expected 32\n")
            return None
        return ed25519.Ed25519PublicKey.from_public_bytes(key)
    if keytype == 16:
        if len(key) != 57:
            sys.stderr.write(f"Wrong key size {len(key)} for Ed448, expected 57\n")
        return ed448.Ed448PublicKey.from_public_bytes(key)
    sys.stderr.write(f"Unsupported key type {keytype}\n")
    return None


ap = argparse.ArgumentParser()
ap.add_argument("input", nargs="+")
ap.add_argument("-d", "--directory", help="Output directory")
args = ap.parse_args()

for fn in args.input:
    if fn == "-":
        content = sys.stdin.read()
    else:
        content = pathlib.Path(fn).read_text(encoding="ascii", errors="replace")

    count = 0
    for rec in re.findall(r"[0-9]{1,3}\s+[0-9]{1,3}\s+[0-9]{1,3}\s+[A-Za-z0-9/+= ]*", content):
        key = rec2key(rec)
        if not key:
            sys.stderr.write(f"Parser error in {fn}\n")
            continue
        pem = key.public_bytes(Encoding.PEM, PublicFormat.SubjectPublicKeyInfo)
        if args.directory:
            ofn = fn.split("/")[-1]
            if count > 0:
                ofn += f".{count}"
            pathlib.Path(f"{args.directory}/{ofn}").write_bytes(pem)
        else:
            print(pem.decode(), end="")
        count += 1
